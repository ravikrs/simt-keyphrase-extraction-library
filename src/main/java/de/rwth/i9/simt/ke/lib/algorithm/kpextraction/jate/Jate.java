package de.rwth.i9.simt.ke.lib.algorithm.kpextraction.jate;

import java.io.File;
import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.solr.client.solrj.SolrServerException;
import org.apache.solr.client.solrj.embedded.EmbeddedSolrServer;
import org.apache.solr.core.CoreContainer;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import uk.ac.shef.dcs.jate.JATEException;
import uk.ac.shef.dcs.jate.JATEProperties;
import uk.ac.shef.dcs.jate.app.AppATTF;
import uk.ac.shef.dcs.jate.app.AppCValue;
import uk.ac.shef.dcs.jate.app.AppChiSquare;
import uk.ac.shef.dcs.jate.app.AppGlossEx;
import uk.ac.shef.dcs.jate.app.AppParams;
import uk.ac.shef.dcs.jate.app.AppRAKE;
import uk.ac.shef.dcs.jate.app.AppRIDF;
import uk.ac.shef.dcs.jate.app.AppTFIDF;
import uk.ac.shef.dcs.jate.app.AppTTF;
import uk.ac.shef.dcs.jate.app.AppTermEx;
import uk.ac.shef.dcs.jate.app.AppWeirdness;
import uk.ac.shef.dcs.jate.model.JATEDocument;
import uk.ac.shef.dcs.jate.model.JATETerm;
import uk.ac.shef.dcs.jate.util.JATEUtil;

public class Jate {
	private static final Logger log = LoggerFactory.getLogger(Jate.class);
	private static int id = 0;

	public static List<JATETerm> TTFAlgo(String text, String solrDir)
			throws JATEException, IOException, SolrServerException {

		Path solrHome = Paths.get(solrDir, "testdata", "solr-testbed");
		String solrHomeDir = solrHome.toString();
		List<JATETerm> terms = new ArrayList<>();
		String solrCoreName = "ACLRDTEC";

		freeSolrLocks(solrDir);

		EmbeddedSolrServer server = null;
		try {
			CoreContainer solrContainer = new CoreContainer(solrHomeDir);
			solrContainer.load();

			server = new EmbeddedSolrServer(solrContainer, solrCoreName);

			JATEDocument jateDocument = new JATEDocument("sample" + String.valueOf(++id));
			jateDocument.setContent(text);
			jateDocument.setId(String.valueOf(id));

			JATEProperties jateProp = new JATEProperties();

			JATEUtil.addNewDoc(server, jateDocument.getId(), jateDocument.getId(), jateDocument.getContent(), jateProp,
					true);

			log.info("AppRAKE ranking and filtering ... ");
			Map<String, String> initParam = new HashMap<>();
			initParam.put(AppParams.PREFILTER_MIN_TERM_TOTAL_FREQUENCY.getParamKey(), "1");
			initParam.put(AppParams.CUTOFF_TOP_K_PERCENT.getParamKey(), "1");

			AppTTF appTTF = new AppTTF(initParam);
			terms = appTTF.extract(server.getCoreContainer().getCore(solrCoreName), jateProp);

			log.info("complete ranking and filtering.");

			/**
			 * The sample results is consistent with original paper.
			 *
			 * The slight difference is caused by two reasons: 1) candidates are
			 * generated by NP chunker rather than stop words filtering; 2) in
			 * JATE 2.0, we do lemmetise/stemming in candidate terms analyser
			 * chain before actual scoring. So, terms may have higher or lower
			 * score than corresponding one in original paper if plural form
			 * exists, e.g., "set", "minimal supporting set", "system",
			 * "corresponding algorithm"
			 */
		} finally {
			// if (server != null) {
			// server.getCoreContainer().getCore(solrCoreName).close();
			// // server.getCoreContainer().shutdown();
			// server.close();
			// }
		}
		return terms;

	}

	public static List<JATETerm> ATTFAlgo(String text, String solrDir)
			throws JATEException, IOException, SolrServerException {

		Path solrHome = Paths.get(solrDir, "testdata", "solr-testbed");
		String solrHomeDir = solrHome.toString();
		List<JATETerm> terms = new ArrayList<>();
		String solrCoreName = "ACLRDTEC";

		freeSolrLocks(solrDir);

		EmbeddedSolrServer server = null;
		try {
			CoreContainer solrContainer = new CoreContainer(solrHomeDir);
			solrContainer.load();

			server = new EmbeddedSolrServer(solrContainer, solrCoreName);

			JATEDocument jateDocument = new JATEDocument("sample" + String.valueOf(++id));
			jateDocument.setContent(text);
			jateDocument.setId(String.valueOf(id));

			JATEProperties jateProp = new JATEProperties();

			JATEUtil.addNewDoc(server, jateDocument.getId(), jateDocument.getId(), jateDocument.getContent(), jateProp,
					true);

			log.info("AppRAKE ranking and filtering ... ");
			Map<String, String> initParam = new HashMap<>();
			initParam.put(AppParams.PREFILTER_MIN_TERM_TOTAL_FREQUENCY.getParamKey(), "1");
			initParam.put(AppParams.CUTOFF_TOP_K_PERCENT.getParamKey(), "1");

			AppATTF appATTF = new AppATTF(initParam);
			terms = appATTF.extract(server.getCoreContainer().getCore(solrCoreName), jateProp);

			log.info("complete ranking and filtering.");

			/**
			 * The sample results is consistent with original paper.
			 *
			 * The slight difference is caused by two reasons: 1) candidates are
			 * generated by NP chunker rather than stop words filtering; 2) in
			 * JATE 2.0, we do lemmetise/stemming in candidate terms analyser
			 * chain before actual scoring. So, terms may have higher or lower
			 * score than corresponding one in original paper if plural form
			 * exists, e.g., "set", "minimal supporting set", "system",
			 * "corresponding algorithm"
			 */
		} finally {
			// if (server != null) {
			// server.getCoreContainer().getCore(solrCoreName).close();
			// // server.getCoreContainer().shutdown();
			// server.close();
			// }
		}
		return terms;

	}

	public static List<JATETerm> TFIDFAlgo(String text, String solrDir)
			throws JATEException, IOException, SolrServerException {

		Path solrHome = Paths.get(solrDir, "testdata", "solr-testbed");
		String solrHomeDir = solrHome.toString();
		List<JATETerm> terms = new ArrayList<>();
		String solrCoreName = "ACLRDTEC";
		freeSolrLocks(solrDir);

		EmbeddedSolrServer server = null;
		try {
			CoreContainer solrContainer = new CoreContainer(solrHomeDir);
			solrContainer.load();

			server = new EmbeddedSolrServer(solrContainer, solrCoreName);

			JATEDocument jateDocument = new JATEDocument("sample" + String.valueOf(++id));
			jateDocument.setContent(text);
			jateDocument.setId(String.valueOf(id));

			JATEProperties jateProp = new JATEProperties();

			JATEUtil.addNewDoc(server, jateDocument.getId(), jateDocument.getId(), jateDocument.getContent(), jateProp,
					true);

			log.info("AppRAKE ranking and filtering ... ");
			Map<String, String> initParam = new HashMap<>();
			initParam.put(AppParams.PREFILTER_MIN_TERM_TOTAL_FREQUENCY.getParamKey(), "1");
			initParam.put(AppParams.CUTOFF_TOP_K_PERCENT.getParamKey(), "1");

			AppTFIDF appTFIDF = new AppTFIDF(initParam);
			terms = appTFIDF.extract(server.getCoreContainer().getCore(solrCoreName), jateProp);
			log.info("complete ranking and filtering.");

			/**
			 * The sample results is consistent with original paper.
			 *
			 * The slight difference is caused by two reasons: 1) candidates are
			 * generated by NP chunker rather than stop words filtering; 2) in
			 * JATE 2.0, we do lemmetise/stemming in candidate terms analyser
			 * chain before actual scoring. So, terms may have higher or lower
			 * score than corresponding one in original paper if plural form
			 * exists, e.g., "set", "minimal supporting set", "system",
			 * "corresponding algorithm"
			 */
		} finally {
			// if (server != null) {
			// server.getCoreContainer().getCore(solrCoreName).close();
			// // server.getCoreContainer().shutdown();
			// server.close();
			// }
		}
		return terms;

	}

	public static List<JATETerm> RIDFAlgo(String text, String solrDir)
			throws JATEException, IOException, SolrServerException {

		Path solrHome = Paths.get(solrDir, "testdata", "solr-testbed");
		String solrHomeDir = solrHome.toString();
		List<JATETerm> terms = new ArrayList<>();
		String solrCoreName = "ACLRDTEC";

		freeSolrLocks(solrDir);

		EmbeddedSolrServer server = null;
		try {
			CoreContainer solrContainer = new CoreContainer(solrHomeDir);
			solrContainer.load();

			server = new EmbeddedSolrServer(solrContainer, solrCoreName);

			JATEDocument jateDocument = new JATEDocument("sample" + String.valueOf(++id));
			jateDocument.setContent(text);
			jateDocument.setId(String.valueOf(id));

			JATEProperties jateProp = new JATEProperties();

			JATEUtil.addNewDoc(server, jateDocument.getId(), jateDocument.getId(), jateDocument.getContent(), jateProp,
					true);

			log.info("AppRAKE ranking and filtering ... ");
			Map<String, String> initParam = new HashMap<>();
			initParam.put(AppParams.PREFILTER_MIN_TERM_TOTAL_FREQUENCY.getParamKey(), "1");
			initParam.put(AppParams.CUTOFF_TOP_K_PERCENT.getParamKey(), "1");

			AppRIDF appRIDF = new AppRIDF(initParam);
			terms = appRIDF.extract(server.getCoreContainer().getCore(solrCoreName), jateProp);

			log.info("complete ranking and filtering.");

			/**
			 * The sample results is consistent with original paper.
			 *
			 * The slight difference is caused by two reasons: 1) candidates are
			 * generated by NP chunker rather than stop words filtering; 2) in
			 * JATE 2.0, we do lemmetise/stemming in candidate terms analyser
			 * chain before actual scoring. So, terms may have higher or lower
			 * score than corresponding one in original paper if plural form
			 * exists, e.g., "set", "minimal supporting set", "system",
			 * "corresponding algorithm"
			 */
		} finally {
			// if (server != null) {
			// server.getCoreContainer().getCore(solrCoreName).close();
			// // server.getCoreContainer().shutdown();
			// server.close();
			// }
		}
		return terms;

	}

	public static List<JATETerm> CValueAlgo(String text, String solrDir)
			throws JATEException, IOException, SolrServerException {

		Path solrHome = Paths.get(solrDir, "testdata", "solr-testbed");
		String solrHomeDir = solrHome.toString();
		List<JATETerm> terms = new ArrayList<>();
		String solrCoreName = "ACLRDTEC";

		freeSolrLocks(solrDir);

		EmbeddedSolrServer server = null;
		try {
			CoreContainer solrContainer = new CoreContainer(solrHomeDir);
			solrContainer.load();

			server = new EmbeddedSolrServer(solrContainer, solrCoreName);

			JATEDocument jateDocument = new JATEDocument("sample" + String.valueOf(++id));
			jateDocument.setContent(text);
			jateDocument.setId(String.valueOf(id));

			JATEProperties jateProp = new JATEProperties();

			JATEUtil.addNewDoc(server, jateDocument.getId(), jateDocument.getId(), jateDocument.getContent(), jateProp,
					true);

			log.info("AppRAKE ranking and filtering ... ");
			Map<String, String> initParam = new HashMap<>();
			initParam.put(AppParams.PREFILTER_MIN_TERM_TOTAL_FREQUENCY.getParamKey(), "1");
			initParam.put(AppParams.CUTOFF_TOP_K_PERCENT.getParamKey(), "1");

			AppCValue appCValue = new AppCValue(initParam);
			terms = appCValue.extract(server.getCoreContainer().getCore(solrCoreName), jateProp);

			log.info("complete ranking and filtering.");

			/**
			 * The sample results is consistent with original paper.
			 *
			 * The slight difference is caused by two reasons: 1) candidates are
			 * generated by NP chunker rather than stop words filtering; 2) in
			 * JATE 2.0, we do lemmetise/stemming in candidate terms analyser
			 * chain before actual scoring. So, terms may have higher or lower
			 * score than corresponding one in original paper if plural form
			 * exists, e.g., "set", "minimal supporting set", "system",
			 * "corresponding algorithm"
			 */
		} finally {
			// if (server != null) {
			// server.getCoreContainer().getCore(solrCoreName).close();
			// // server.getCoreContainer().shutdown();
			// server.close();
			// }
		}
		return terms;

	}

	public static List<JATETerm> ChiSquareAlgo(String text, String solrDir)
			throws JATEException, IOException, SolrServerException {

		Path solrHome = Paths.get(solrDir, "testdata", "solr-testbed");
		String solrHomeDir = solrHome.toString();
		List<JATETerm> terms = new ArrayList<>();
		String solrCoreName = "ACLRDTEC";

		freeSolrLocks(solrDir);

		EmbeddedSolrServer server = null;
		try {
			CoreContainer solrContainer = new CoreContainer(solrHomeDir);
			solrContainer.load();

			server = new EmbeddedSolrServer(solrContainer, solrCoreName);

			JATEDocument jateDocument = new JATEDocument("sample" + String.valueOf(++id));
			jateDocument.setContent(text);
			jateDocument.setId(String.valueOf(id));

			JATEProperties jateProp = new JATEProperties();

			JATEUtil.addNewDoc(server, jateDocument.getId(), jateDocument.getId(), jateDocument.getContent(), jateProp,
					true);

			log.info("AppRAKE ranking and filtering ... ");
			Map<String, String> initParam = new HashMap<>();
			initParam.put(AppParams.PREFILTER_MIN_TERM_TOTAL_FREQUENCY.getParamKey(), "1");
			initParam.put(AppParams.CUTOFF_TOP_K_PERCENT.getParamKey(), "1");

			AppChiSquare appChiSquare = new AppChiSquare(initParam);
			terms = appChiSquare.extract(server.getCoreContainer().getCore(solrCoreName), jateProp);

			log.info("complete ranking and filtering.");

			/**
			 * The sample results is consistent with original paper.
			 *
			 * The slight difference is caused by two reasons: 1) candidates are
			 * generated by NP chunker rather than stop words filtering; 2) in
			 * JATE 2.0, we do lemmetise/stemming in candidate terms analyser
			 * chain before actual scoring. So, terms may have higher or lower
			 * score than corresponding one in original paper if plural form
			 * exists, e.g., "set", "minimal supporting set", "system",
			 * "corresponding algorithm"
			 */
		} finally {
			// if (server != null) {
			// server.getCoreContainer().getCore(solrCoreName).close();
			// // server.getCoreContainer().shutdown();
			// server.close();
			// }
		}
		return terms;

	}

	public static List<JATETerm> WeirdnessAlgo(String text, String solrDir)
			throws JATEException, IOException, SolrServerException {

		Path solrHome = Paths.get(solrDir, "testdata", "solr-testbed");
		String solrHomeDir = solrHome.toString();
		List<JATETerm> terms = new ArrayList<>();
		String solrCoreName = "ACLRDTEC";

		freeSolrLocks(solrDir);

		EmbeddedSolrServer server = null;
		try {
			CoreContainer solrContainer = new CoreContainer(solrHomeDir);
			solrContainer.load();

			server = new EmbeddedSolrServer(solrContainer, solrCoreName);

			JATEDocument jateDocument = new JATEDocument("sample" + String.valueOf(++id));
			jateDocument.setContent(text);
			jateDocument.setId(String.valueOf(id));

			JATEProperties jateProp = new JATEProperties();

			JATEUtil.addNewDoc(server, jateDocument.getId(), jateDocument.getId(), jateDocument.getContent(), jateProp,
					true);

			log.info("AppRAKE ranking and filtering ... ");
			Map<String, String> initParam = new HashMap<>();
			initParam.put(AppParams.PREFILTER_MIN_TERM_TOTAL_FREQUENCY.getParamKey(), "1");
			initParam.put(AppParams.CUTOFF_TOP_K_PERCENT.getParamKey(), "1");
			initParam.put(AppParams.REFERENCE_FREQUENCY_FILE.getParamKey(),
					solrDir + "/testdata/solr-testbed/ACLRDTEC/conf/bnc_unifrqs.normal");

			AppWeirdness appWeirdness = new AppWeirdness(initParam);
			terms = appWeirdness.extract(server.getCoreContainer().getCore(solrCoreName), jateProp);

			log.info("complete ranking and filtering.");

			/**
			 * The sample results is consistent with original paper.
			 *
			 * The slight difference is caused by two reasons: 1) candidates are
			 * generated by NP chunker rather than stop words filtering; 2) in
			 * JATE 2.0, we do lemmetise/stemming in candidate terms analyser
			 * chain before actual scoring. So, terms may have higher or lower
			 * score than corresponding one in original paper if plural form
			 * exists, e.g., "set", "minimal supporting set", "system",
			 * "corresponding algorithm"
			 */
		} finally {
			// if (server != null) {
			// server.getCoreContainer().getCore(solrCoreName).close();
			// // server.getCoreContainer().shutdown();
			// server.close();
			// }
		}
		return terms;

	}

	public static List<JATETerm> GlossExAlgo(String text, String solrDir)
			throws JATEException, IOException, SolrServerException {

		Path solrHome = Paths.get(solrDir, "testdata", "solr-testbed");
		String solrHomeDir = solrHome.toString();
		List<JATETerm> terms = new ArrayList<>();
		String solrCoreName = "ACLRDTEC";

		freeSolrLocks(solrDir);

		EmbeddedSolrServer server = null;
		try {
			CoreContainer solrContainer = new CoreContainer(solrHomeDir);
			solrContainer.load();

			server = new EmbeddedSolrServer(solrContainer, solrCoreName);

			JATEDocument jateDocument = new JATEDocument("sample" + String.valueOf(++id));
			jateDocument.setContent(text);
			jateDocument.setId(String.valueOf(id));

			JATEProperties jateProp = new JATEProperties();

			JATEUtil.addNewDoc(server, jateDocument.getId(), jateDocument.getId(), jateDocument.getContent(), jateProp,
					true);

			log.info("AppRAKE ranking and filtering ... ");
			Map<String, String> initParam = new HashMap<>();
			initParam.put(AppParams.PREFILTER_MIN_TERM_TOTAL_FREQUENCY.getParamKey(), "1");
			initParam.put(AppParams.CUTOFF_TOP_K_PERCENT.getParamKey(), "1");
			initParam.put(AppParams.REFERENCE_FREQUENCY_FILE.getParamKey(),
					solrDir + "/testdata/solr-testbed/ACLRDTEC/conf/bnc_unifrqs.normal");

			AppGlossEx appGlossEx = new AppGlossEx(initParam);
			terms = appGlossEx.extract(server.getCoreContainer().getCore(solrCoreName), jateProp);

			log.info("complete ranking and filtering.");

			/**
			 * The sample results is consistent with original paper.
			 *
			 * The slight difference is caused by two reasons: 1) candidates are
			 * generated by NP chunker rather than stop words filtering; 2) in
			 * JATE 2.0, we do lemmetise/stemming in candidate terms analyser
			 * chain before actual scoring. So, terms may have higher or lower
			 * score than corresponding one in original paper if plural form
			 * exists, e.g., "set", "minimal supporting set", "system",
			 * "corresponding algorithm"
			 */
		} finally {
			// if (server != null) {
			// server.getCoreContainer().getCore(solrCoreName).close();
			// // server.getCoreContainer().shutdown();
			// server.close();
			// }
		}
		return terms;

	}

	public static List<JATETerm> TermExAlgo(String text, String solrDir)
			throws JATEException, IOException, SolrServerException {

		Path solrHome = Paths.get(solrDir, "testdata", "solr-testbed");
		String solrHomeDir = solrHome.toString();
		List<JATETerm> terms = new ArrayList<>();
		String solrCoreName = "ACLRDTEC";

		freeSolrLocks(solrDir);

		EmbeddedSolrServer server = null;
		try {
			CoreContainer solrContainer = new CoreContainer(solrHomeDir);
			solrContainer.load();

			server = new EmbeddedSolrServer(solrContainer, solrCoreName);

			JATEDocument jateDocument = new JATEDocument("sample" + String.valueOf(++id));
			jateDocument.setContent(text);
			jateDocument.setId(String.valueOf(id));

			JATEProperties jateProp = new JATEProperties();

			JATEUtil.addNewDoc(server, jateDocument.getId(), jateDocument.getId(), jateDocument.getContent(), jateProp,
					true);

			log.info("AppRAKE ranking and filtering ... ");
			Map<String, String> initParam = new HashMap<>();
			initParam.put(AppParams.PREFILTER_MIN_TERM_TOTAL_FREQUENCY.getParamKey(), "1");
			initParam.put(AppParams.CUTOFF_TOP_K_PERCENT.getParamKey(), "1");
			initParam.put(AppParams.REFERENCE_FREQUENCY_FILE.getParamKey(),
					solrDir + "/testdata/solr-testbed/ACLRDTEC/conf/bnc_unifrqs.normal");

			AppTermEx appTermEx = new AppTermEx(initParam);
			terms = appTermEx.extract(server.getCoreContainer().getCore(solrCoreName), jateProp);

			log.info("complete ranking and filtering.");

			/**
			 * The sample results is consistent with original paper.
			 *
			 * The slight difference is caused by two reasons: 1) candidates are
			 * generated by NP chunker rather than stop words filtering; 2) in
			 * JATE 2.0, we do lemmetise/stemming in candidate terms analyser
			 * chain before actual scoring. So, terms may have higher or lower
			 * score than corresponding one in original paper if plural form
			 * exists, e.g., "set", "minimal supporting set", "system",
			 * "corresponding algorithm"
			 */
		} finally {
			// if (server != null) {
			// server.getCoreContainer().getCore(solrCoreName).close();
			// // server.getCoreContainer().shutdown();
			// server.close();
			// }
		}
		return terms;

	}

	public static List<JATETerm> RAKEAlgo(String text, String solrDir)
			throws JATEException, IOException, SolrServerException {

		Path solrHome = Paths.get(solrDir, "testdata", "solr-testbed");
		String solrHomeDir = solrHome.toString();
		List<JATETerm> terms = new ArrayList<>();
		String solrCoreName = "ACLRDTEC";
		freeSolrLocks(solrDir);

		EmbeddedSolrServer server = null;
		try {
			CoreContainer solrContainer = new CoreContainer(solrHomeDir);
			solrContainer.load();

			server = new EmbeddedSolrServer(solrContainer, solrCoreName);

			JATEDocument jateDocument = new JATEDocument("sample" + String.valueOf(++id));
			jateDocument.setContent(text);
			jateDocument.setId(String.valueOf(id));

			JATEProperties jateProp = new JATEProperties();

			JATEUtil.addNewDoc(server, jateDocument.getId(), jateDocument.getId(), jateDocument.getContent(), jateProp,
					true);

			log.info("AppRAKE ranking and filtering ... ");
			Map<String, String> initParam = new HashMap<>();
			initParam.put(AppParams.PREFILTER_MIN_TERM_TOTAL_FREQUENCY.getParamKey(), "1");
			initParam.put(AppParams.CUTOFF_TOP_K_PERCENT.getParamKey(), "1");

			AppRAKE appRAKE = new AppRAKE(initParam);
			terms = appRAKE.extract(server.getCoreContainer().getCore(solrCoreName), jateProp);

			log.info("complete ranking and filtering.");

			/**
			 * The sample results is consistent with original paper.
			 *
			 * The slight difference is caused by two reasons: 1) candidates are
			 * generated by NP chunker rather than stop words filtering; 2) in
			 * JATE 2.0, we do lemmetise/stemming in candidate terms analyser
			 * chain before actual scoring. So, terms may have higher or lower
			 * score than corresponding one in original paper if plural form
			 * exists, e.g., "set", "minimal supporting set", "system",
			 * "corresponding algorithm"
			 */
		} finally {
			// if (server != null) {
			// server.getCoreContainer().getCore(solrCoreName).close();
			// // server.getCoreContainer().shutdown();
			// server.close();
			// }
		}
		return terms;

	}

	private static void freeSolrLocks(String solrDir) {
		Path solrHome = Paths.get(solrDir, "testdata", "solr-testbed");
		String solrCoreName = "ACLRDTEC";
		File lock = Paths.get(solrHome.toString(), solrCoreName, "data", "index", "write.lock").toFile();
		if (lock.exists()) {
			System.err.println("Previous solr did not shut down cleanly. Unlock it ...");
			lock.delete();
		}
		solrCoreName = "GENIA";
		lock = Paths.get(solrHome.toString(), solrCoreName, "data", "index", "write.lock").toFile();
		if (lock.exists()) {
			System.err.println("Previous solr did not shut down cleanly. Unlock it ...");
			lock.delete();
		}
		solrCoreName = "jateCore";
		lock = Paths.get(solrHome.toString(), solrCoreName, "data", "index", "write.lock").toFile();
		if (lock.exists()) {
			System.err.println("Previous solr did not shut down cleanly. Unlock it ...");
			lock.delete();
		}

	}

}
